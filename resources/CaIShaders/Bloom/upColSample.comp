#version 450 core

layout (binding = 0) uniform UniformBufferObject {
    float maxLod;
    float dstLod;
    vec2 invDstScale;
    vec2 dstScale;
} _UBO;

layout (binding = 1) uniform sampler2D srcImage;
layout (binding = 2) uniform sampler2D blendImage;


layout(binding = 3, rgba16f) uniform writeonly image2D dstImage;


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

    const int R = 8;
    float K[2 * R + 1];
    void computeGaussianKernel(int radius, float sigma, out float weights[2 * R + 1])
    {
        float sum = 0.0;
        for (int i = -radius; i <= radius; i++) {
            float x = float(i);
            float w = exp(-(x * x) / (2.0 * sigma * sigma));
            weights[i + radius] = w;
            sum += w;
        }

        for (int i = 0; i < 2 * radius + 1; i++) {
            weights[i] /= sum;
        }
    }


    void main(){
        computeGaussianKernel(R, 1.0, K);

        ivec2 p = ivec2(gl_GlobalInvocationID.xy);
        if (any(greaterThanEqual(p, _UBO.dstScale))) return;

        vec2 uv = (vec2(p) + 0.5) * _UBO.invDstScale; // 提前算好1 / _UBO.dstScale
        vec3 acc = vec3(0.0);

        // 中心
        acc += K[R] * textureLod(srcImage, uv, _UBO.dstLod).rgb;

        // 上下（纵向偏移）
        for (int o = 1; o <= R; ++o) {
            vec2 off = vec2(0.0, _UBO.invDstScale.y * float(o));
            acc += K[R +  o] * textureLod(srcImage, uv + off, _UBO.dstLod).rgb; // 采样自动处理边界
            acc += K[R -  o] * textureLod(srcImage, uv - off, _UBO.dstLod).rgb;
        }

        uv = (vec2(p) + 0.5) * _UBO.invDstScale;
        if(_UBO.dstLod < _UBO.maxLod){
            acc += textureLod(blendImage, uv, _UBO.dstLod + 1).rgb; //叠加前一层的颜色, blendImage是dstImage的Storage绑定
        }
        imageStore(dstImage, p, vec4(acc, 1.0));
    }


