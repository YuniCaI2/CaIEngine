Settings{
    localX 16
    localY 16
    localZ 1
}

Properties{
    float maxLod
    float dstLod
    vec2 invDstScale
    vec2 dstScale
    sampler2D srcImage
    sampler2D blendImage
}

SSBO{
    Write Image2D RGBA16F dstImage
}

Program{
    const int R = 8;
    float K[2 * R + 1];
    void computeGaussianKernel(int radius, float sigma, out float weights[2 * R + 1])
    {
        float sum = 0.0;
        for (int i = -radius; i <= radius; i++) {
            float x = float(i);
            float w = exp(-(x * x) / (2.0 * sigma * sigma));
            weights[i + radius] = w;
            sum += w;
        }

        for (int i = 0; i < 2 * radius + 1; i++) {
            weights[i] /= sum;
        }
    }


    void main(){
        computeGaussianKernel(R, 2.5, K);

        ivec2 p = ivec2(gl_GlobalInvocationID.xy);
        if (any(greaterThanEqual(p, dstScale))) return;

        vec2 uv = (vec2(p) + 0.5) * invDstScale; // 提前算好1 / dstScale
        vec3 acc = vec3(0.0);


        if(dstLod < maxLod){
            acc += textureLod(blendImage, uv, dstLod + 1).rgb; //叠加前一层的颜色, blendImage是dstImage的Storage绑定
        }
        // 中心

        acc += K[R] * textureLod(srcImage, uv, dstLod).rgb;

        // 上下（纵向偏移）
        for (int o = 1; o <= R; ++o) {
            vec2 off = vec2(0.0, invDstScale.y * float(o));
            acc += K[R +  o] * textureLod(srcImage, uv + off, dstLod).rgb; // 采样自动处理边界
            acc += K[R -  o] * textureLod(srcImage, uv - off, dstLod).rgb;
        }

        imageStore(dstImage, p, vec4(acc, 1.0));
    }


}